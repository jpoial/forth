( INDEX+  tm  B+Tree Indexing System for Forth       01/10/84 )                                                                 ( requires Laboratory Microsystems Forth )                                                                                      ( Copyright 1983                                )               ( Business Computing Press                      )               ( 2210 Wilshire Blvd.  Suite 289                )               ( Santa Monica, CA  90403                       )                                                                               modified 1/10/84 for Forth-83                                                                                                   11.02.1991 muutujate massiiv. A. Isotamm.                                                                                                                                                                                                                                                                                       ( INDEX+  Copyright Business Computing Press 1983             ) ( INDEX+ is a Trade Mark of Business Computing Press          ) : INDEX+  ( --- )    ( MARK BEGINNING OF INDEX+ IN DICTIONARY )    CR CR                                                           ." INDEX+  Version 2.2"                    CR                   ."         (c) Copyright 1983"             CR                   ."         Business Computing Press"       CR                   ."         2210 Wilshire Blvd.  Suite 289" CR                   ."         Santa Monica, CA  90403"        CR ;               INDEX+                       ( DISPLAY NOTICE )                : VSEL      ( 16_par 32_par --- right_par )                        WSIZE 2 <> IF SWAP THEN DROP ;                                1 CONSTANT K-BASESCR         ( BASE LOAD SCREEN # )            : ILOAD CR DUP 3 .R K-BASESCR + 1- ."  * " DUP . LOAD ;         ( LOAD MASTER LOAD SCREEN )                                       2 ILOAD                                                       ( INDEX+  MASTER LOAD SCREEN                                  )                                                                 ( LOAD SUBMASTER LOAD SCREENS )                                  3 ILOAD  ( UTILITIES )                                         10 ILOAD  ( CONSTANTS, VARIABLES )                              20 ILOAD  ( FILE ACCESS PRIMITIVES )                            30 ILOAD  ( INDEX+ PRIMITIVES 1 )                               40 ILOAD  ( INDEX+ PRIMITIVES 2 )                               50 ILOAD  ( INDEX+ PRIMITIVES 3 )                               60 ILOAD  ( INDEX+ INTERMEDIATES 1 )                            70 ILOAD  ( INDEX+ INTERMEDIATES 2 )                            80 ILOAD  ( INDEX+ HIGH LEVEL )                                 ( 90 ILOAD  ) ( TUTORIAL )                                                                                                      CR .( Completed loading INDEX+) CR CR                                                                                           ( INDEX+  LOAD UTILITIES                                      )                                                                  7 ILOAD  ( UTILITIES 1 )                                        8 ILOAD  ( UTILITIES 2 )                                        9 ILOAD  ( UTILITIES 3 )                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ( System messages )                                             empty stack                                                     dictionary full                                                 has incorrect address mode                                      is redefined                                                    is undefined                                                    disk address out of range                                       stack overflow                                                  disk error                                                      illegal data type                                               illegal character                                                                                                               BASE must be BINARY                                             BASE must be DECIMAL                                            missing decimal point                                           PC/FORTH 2.0                             Laboratory Microsystems( System messages )                                             compilation only, use in definition                             execution only                                                  conditionals not paired                                         definition not finished                                         in protected dictionary                                         use only when loading                                           off current editing screen                                      declare vocabulary                                              in string                                                                                                                                                                                       illegal dimension in array definition                           negative array index                                            array index too large                                                                                                           ( 8086 Assembler messages )                                     16 bit register not allowed                                     8 bit register not allowed                                      address out of range                                            immediate data value not allowed                                missing source register                                         missing destination register                                    illegal operation                                               illegal operand                                                 instruction not implemented                                     illegal destination register                                    illegal source register                                         illegal condition code                                          register mismatch                                               destination address missing                                                                                                     ( INDEX+  UTILITIES  UDROP  UDROP3  DROPS  -ROT  3DUP         )                                                                 : UDROP ( A B C --- A C ) ( UNDER DROP )                             SWAP DROP ;                                                : UDROP3 ( A B C --- B C ) ( DROP THIRD ITEM ON STACK )              ROT DROP ;                                                 : UDROPS ( 1 2 3 .... x A X --- A ) ( UDROPS X ITEMS )               0 ?DO UDROP LOOP ;                                         : DROPS ( 1 2 3 .... x X --- ) ( DROPS X ITEMS )                        0 ?DO DROP LOOP ;                                                                                                       : -ROT  ( A B C --- C A B ) ( REVERSE ROT )                          ROT ROT ;                                                                                                                  : 3DUP  ( A B C --- A B C A B C ) ( DUP 3 ITEMS )                  2DUP 4 PICK -ROT ;                                           ( INDEX+  UTILITIES  D=   P-CFLAG  ?DUP              01/09/84 )                                                                 : P-CFLAG     ( n --- cflag )  ( sets cflag from comparison )                                  ( -1=0<   0=0   1=0  )              DUP ABS ?DUP                ( NON-ZERO? )                       IF / THEN ;                                                                                                                  ;S                                                                                                                              ( removed for PC/FORTH 2.0 )                                    : D=   ( d1 d2 --- tflag )   ( DOUBLE EQUALS )                     ROT =   ( COMPARE HIGH BYTE )                                   -ROT =  ( COMPARE LOW BYTE )                                    AND ;   ( AND FLAGS )                                                                                                                                                                        ( INDEX+  UTILITIES  -CMOVE                          01/09/84 ) : -CMOVE  CMOVE> ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ( INDEX+  LOAD CONSTANTS AND VARIABLES                        )                                                                                                                                                                                                  11 ILOAD  ( HEADER VARIABLE OFFSETS )                           12 ILOAD  ( MISC CONSTANTS )                                    13 ILOAD  ( FIB VARIABLE OFFSETS )                              14 ILOAD  ( NODE VARIABLE OFFSETS )                             15 ILOAD  ( MISC CONSTANTS )                                    16 ILOAD  ( VARIABLES )                                         17 ILOAD  ( VARIABLES )                                         18 ILOAD  ( VARIABLES )                                         19 ILOAD  ( ERROR CODE CONSTANTS )                                                                                                                                                                                                                             ( INDEX+  HEADER VARIABLE OFFSETS                    01/09/84 )                                                                 ( HEADER VARIABLE OFFSETS )                                                                                                     0 0   VSEL    CONSTANT H-VERSION   ( CURRENT VERSION OF REL. )  2 4   VSEL    CONSTANT H-FIRST     ( FIRST INDEX NODE POINTER ) 4 8   VSEL    CONSTANT H-LAST      ( LAST INDEX NODE POINTER )  6 12  VSEL    CONSTANT H-NEXT      ( NEXT AVALIABLE NODE # )    8 16  VSEL    CONSTANT H-EOF       ( END OF FILE )              10 20 VSEL    CONSTANT H-LEVELS    ( DEPTH OF TREE )                                                                                                                                                                                                                                                                                                                                                                                                            ( INDEX+  CONSTANTS                                  01/09/84 )                                                                 ( MISC CONSTANTS )                                                                                                                  8 CONSTANT K-INDEXES  ( NUMBER OF INDEXES ALLOWED )           240 CONSTANT K-EOF      ( END OF FILE LIMIT FOR INDEX )        1024 CONSTANT K-1K       ( THE VALUE 1024 )                        0 CONSTANT K-ROOT     ( LOCATION OF ROOT NODE )                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ( INDEX+  FIB VARIABLE OFFSETS                       01/09/84 )                                                                 ( FIB VARIABLE OFFSETS )                                                                                                        0 0 VSEL CONSTANT F-NODE     ( LAST LEAF NODE READ )            2 4 VSEL CONSTANT F-KEY      ( REL. KEY # OF LAST KEY FOUND)    4 8 VSEL CONSTANT F-FCB      ( FCB ADDRESS FOR INDEX FILE )                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ( INDEX+  CONSTANTS                                  01/09/84 )                                                                 ( NODE VARIABLE OFFSETS )                                                                                                       0 0 VSEL CONSTANT K-NLEVEL     ( LEVEL OF NODE 0=LEAF >0=INDEX) 2 4 VSEL CONSTANT K-NCOUNT     ( KEYCOUNT OF NODE )             4 8 VSEL CONSTANT K-NSPACE     ( AVALIABLE SPACE IN NODE )      6 12 VSEL  CONSTANT K-NP0        ( P0 POINTER OF NODE )         8 16 VSEL  CONSTANT K-NFORWARD   ( FORWARD POINTER )            10 20 VSEL CONSTANT K-NREVERSE   ( REVERSE POINTER )                                                                                                                                                                                                                                                                                                                                                                                                            ( INDEX+  CONSTANTS                                  01/09/84 )                                                                 ( MISC CONSTANTS )                                                                                                              12 24 VSEL CONSTANT K-NBEGIN    ( WHERE NODE STARTS )           12 24 VSEL CONSTANT K-HDRLEN    ( LEHGTH OF HEADER )            6 12  VSEL CONSTANT K-FIBLEN    ( LEHGTH OF FIB )               1 2   VSEL CONSTANT K-VERSION   ( VERSION OF INDEX+ )                                                                                 K-1K K-NBEGIN   - CONSTANT K-NODESIZE  ( SIZE FOR KEYS )  K-NODESIZE K-HDRLEN   - CONSTANT K-ROOTSIZE  ( SIZE OF ROOT )     K-NBEGIN K-ROOTSIZE + CONSTANT K-NHDR      ( START OF HEADER )                                                                                                                                                                                                                                                                ( INDEX+  VARIABLES                                  02/13/91 ) VARIABLE IX-PARM   ( Massiiv[1:2580] )                          : I-HEADER IX-PARM @ ;     ( HEADER INFORMATION )               : I-TEMPKEY ( STOREGE FOR INDEX KEY )                           IX-PARM @ 24 + ;                                                : I-STREE ( SEARCH PATH THROUGH TREE )                          IX-PARM @ 288 + ;                                               : I-IND  ( INDEX NUMBER PASSED ON STACK )                       IX-PARM @ 368 + ;                                               : I-REC  ( RECORD NUMBER PASSED ON STACK )                      IX-PARM @ 372 + ;                                               : I-SKEY ( PTR TO SEARCH KEY ADDR )                             IX-PARM @ 376 + ;                                               : I-EC   ( ERROR CODE TEMP STORAGE )                            IX-PARM @ 380 + ;                                                                                                               ( INDEX+  VARIABLES                                  02/13/91 )                                                                 0 CONSTANT K-BUFA              ( FLAG INDICATING BUFFER A )     1 CONSTANT K-BUFB              ( FLAG INDICATING BUFFER B )                                                                     : I-BUF  ( 2K BUFFER FOR DISK I/O - A&B )                       IX-PARM @ 384 + ;                                               : I-BCB/A ( CONTROL BLOCK FOR BUFFER A )                        IX-PARM @ 2432 + ;                                              : I-BCB/B ( CONTROL BLOCK FOR BUFFER B )                        IX-PARM @ 2440 + ;                                              : I-FIB  ( INDEX FIBS )                                         IX-PARM @ 2448 + ;                                              : K-SPLIT ( --- n = LIMIT FOR SPLIT )                           I-BUF K-NODESIZE 2 / + ;                                                                                                        ( INDEX+  VARIABLES                                  02/13/91 )                                                                 : I-TEMPP0     ( TEMP STORAGE FOR I0 OF B )                     IX-PARM @ 2556 + ;                                              : I-TEMPFWD    ( TEMP STORAGE FOR FWD OF B )                    IX-PARM @ 2560 + ;                                              : I-HIGHKEY    ( HIGH KEY STORAGE )                             IX-PARM @ 2564 + ;                                              : I-ANODE      ( NODE# OF "A" NODE DURING SPLIR )               IX-PARM @ 2568 + ;                                              : I-NOSPLIT    ( NO SPLIT ADDR YET FLAG )                       IX-PARM @ 2572 + ;                                              : I-EXERR      ( 0= DID EXTEND OK, 0> EXTEND ERROR )            IX-PARM @ 2576 + ;                                                                                                                                                                              ( INDEX+  ERROR CODES                                         )                                                                   20  CONSTANT   E-INDEX#               ( BAD INDEX# )            30  CONSTANT   E-EOF                  ( END OF FILE )                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ( INDEX+  LOAD FILE ACESS PRIMITIVES                          )                                                                 ( LOAD SCREENS 21 AND 22 FOR BLOCK STYLE DISK I/O )                                                                             ( 21 ILOAD     ( P-READ )                                       ( 22 ILOAD     ( P-WRITE )                                                                                                      ( LOAD SCREENS 23 - 25 FOR CP/M OR MS-DOS STYLE DISK I/O )                                                                      ( 23 ILOAD     ( OS FILE INTERFACE UTILITY WORDS )              ( 24 ILOAD     ( OS P-READ )                                    ( 25 ILOAD     ( OS P-WRITE )                                                                                                   ( LOAD SCREENS 25 AND 26 FOR FORTH32/83 STYLE DISK I/O )          25 ILOAD     ( FORTH32/83 P-READ )                              26 ILOAD     ( FORTH32/83 P-WRITE )                           ( INDEX+  FILE ACESS PRIMITIVES    P-READ                     )                                                                 : P-READ ( index# node# --- ec )                                   BLOCK I-BUF K-1K CMOVE DROP                                     DISK-ERROR @ ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ( INDEX+  FILE ACESS PRIMITIVES    P-WRITE                    )                                                                 : P-WRITE ( index# node# addr --- ec )                             SWAP DUP K-EOF >                                                  IF 3 DROPS E-EOF               ( PAST END OF FILE )             ELSE BLOCK K-1K CMOVE UPDATE   ( ELSE OK, WRITE BLOCK )              SAVE-BUFFERS              ( WRITE TO DISK )                     DROP                      ( IGNORE INDEX#, NO ERRORS )     THEN ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ( INDEX+  FILE INTERFACE WORDS    P-NODE>REC  P-INDEX>FCB     )                                                                 : P-NODE>REC    ( node# --- rec# )  ( TRANSLATE TO CP/M REC )      8 * ;                   ( 8 SECTORS PER 1K NODE )                                                                            : P-INDEX>FCB   ( index# --- fcbaddr ) ( GET FCBADDR OF INDEX )    K-FIBLEN * I-FIB +      ( OFFSET INTO ARRAY FOR INDEX )         F-FCB + @  ;            ( GET FCB ADDR )                     ( siin oli K-FCB, mida polegi defineeritud )                                                                                    ( : STACKPTR   ) ( --- ) ( PRINTS STACK TO PRINTER )            (   PRINTER CR .STACK CONSOLE ;   )                                                                                                                                                                                                                                                                                             ( INDEX+  FILE INTERFACE WORDS    P-READ                      )                                                                 : P-READ  ( index# node# --- ec )   ( 0ec=good -5ec=read error )   P-NODE>REC        ( GET ACTUAL RECORD # )                       SWAP P-INDEX>FCB  ( GET FCB ADDR )                              SWAP 0 8 0 ?DO    ( 8 CP/M RECS=1 BLOCK STK=fcbaddr rec# ec )      DROP 2DUP I +       ( Ith CP/M RECORD TO READ )                 READ-RANDOM         ( READ RECORD )                             DUP 0=              ( IF READ ERROR )                           IF DROP E-EOF LEAVE ( SET ERROR CODE )                          ELSE                ( STK=fcbaddr rec# bufferaddr )                I-BUF 128 I * +  ( ADDR INTO I-BUF TO PUT RECORD READ )         128 CMOVE 0      ( MOVE INTO I-BUF )                         THEN                                                         LOOP UDROP UDROP ;  ( PRESERVE ERROR CODE )                                                                                  ( INDEX+  FILE ACESS PRIMITIVES    P-READ                     ) : P-INDEX>FCB ( INDEX# --- FCBADDR ) ( GET FCBADDR OF INDEX )      K-FIBLEN * I-FIB +    ( OFFSET INTO ARRAY OF INDEX )            F-FCB + @ ;           ( GET FCB ADDR )                                                                                       : P-READ ( index# node# --- ec )                                   K-1K * OVER P-INDEX>FCB 0 SWAP seek ( COUNT DISPLACEMENT )      IF                                  ( OK! READ NODE )             DROP I-BUF K-1K ROT P-INDEX>FCB R/ ( DROP ACT.DISP. & READ)     IF  DROP 0             ( DROP BYTES-READ & RET. OK FLAG )       THEN                                                          THEN                                                         ;                                                                                                                                                                                                                                                               ( INDEX+  FILE ACESS PRIMITIVES    P-WRITE                    )                                                                 : P-WRITE ( index# node# addr --- ec )                             SWAP K-1K * ROT SWAP OVER P-INDEX>FCB                           0 SWAP seek                      ( COUNT DISPLACEMENT )         IF                               ( OK! WRITE NODE )               DROP  P-INDEX>FCB K-1K SWAP /W ( DROP ACT.DISP & WRITE )        IF DROP 0              ( DROP BYTES-WRITED & RET. OK FLAG )     THEN                                                          THEN                                                         ;                                                                                                                                                                                                                                                                                                                                                                                               ( INDEX+  BLANK SCREEN                                        )                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ( INDEX+  BLANK SCREEN                                        )                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ( INDEX+  BLANK SCREEN                                        )                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ( INDEX+  LOAD PRIMITIVE WORDS 1                              )                                                                 31 ILOAD   ( P-A>B  ETC )                                       32 ILOAD   ( P-HEADER P-A@   ETC )                              33 ILOAD   ( P-NLEVEL!  ETC )                                   34 ILOAD   ( P-NLEVEL@  ETC )                                   35 ILOAD   ( P-BUILDKEY  P-?INDEX#   ETC )                      36 ILOAD   ( P-HINIT  P-INITFIB )                               37 ILOAD   ( P-INITROOT )                                       38 ILOAD   ( P-BUFA?  ETC )                                                                                                                                                                                                                                                                                                                                                                                                                                     ( INDEX+  PRIMITIVES      P-B>A  P-A>B  P-3PARM!  ETC         ) : P-B>A ( --- )  ( TRANSFER CONTENTS OF BUFFER B TO BUFFER A )     I-BUF DUP K-1K + SWAP K-1K CMOVE ( MOVE CONTENTS )              I-BCB/B 2@ I-BCB/A 2! ;          ( SET BUFFER CONTROL BLOCK )                                                                : P-A>B ( --- )  ( TRANSFER CONTENTS OF BUFFER A TO BUFFER B )     I-BUF DUP K-1K + K-1K CMOVE      ( MOVE CONTENTS )              I-BCB/A 2@ I-BCB/B 2! ;          ( SET BUFFER CONTROL BLOCK )                                                                : P-3PARM!  ( skey-addr rec# index# --- ) ( SAVE 3 INPUT PARMS )   I-IND !  I-REC !  I-SKEY ! ;                                 : P-1PARM!  ( index# --- ) ( SAVE 1 INPUT PARM )                   0 0 ROT P-3PARM! ;                  ( SAVE AND CLEAR OTHERS ): P-2PARM!  ( skey-addr index# --- ) ( SAVE 2 INPUT PARMS )        0 SWAP  P-3PARM! ;                   ( SAVE AND CLEAR I-REC )                                                                ( INDEX+  PRIMITIVES   P-HEADER   P-A@  P-B@  P-A!  P-B!      ) : P-HEADER   ( --- hdr-addr )  ( ADDR OF HDR OFF )                 I-BUF K-NHDR + ;                                                                                                             : P-CFIB ( --- fib-addr )  ( RETURN CURRENT FIB ADDRESS )          I-IND @ K-FIBLEN * I-FIB + ; ( CALC FIB LOC FROM INDEX # )                                                                   : P-A@ ( --- index# node# ) ( FETCH CONTROL INFO OF BUFFA )        I-BCB/A 2@ ;                                                 : P-B@ ( --- index# node# ) ( FETCH CONTROL INFO OF BUFFB )        I-BCB/B 2@ ;                                                                                                                 : P-A! ( index# node# --- ) ( STORE CONTROL INFO OF BUFFA )        I-BCB/A 2! ;                                                 : P-B! ( index# node# --- ) ( STORE CONTROL INFO OF BUFFB )        I-BCB/B 2! ;                                                 ( INDEX+  PRIMITIVES   P-NLEVEL!  ETC                         )                                                                 : P-NLEVEL!  ( n --- ) ( STORES LEVEL IN BUF )                     I-BUF K-NLEVEL + ! ;                                         : P-NCOUNT!  ( n --- ) ( STORES COUNT IN BUF )                     I-BUF K-NCOUNT + ! ;                                         : P-NSPACE!  ( n --- ) ( STORES SPACE IN BUF )                     I-BUF K-NSPACE + ! ;                                         : P-NP0!     ( n --- ) ( STORES P0 IN BUF )                        I-BUF K-NP0 + ! ;                                            : P-NFORWARD!  ( n --- ) ( STORES FORWARD IN BUF )                 I-BUF K-NFORWARD + ! ;                                       : P-NREVERSE!  ( n --- ) ( STORES REVERSE IN BUF )                 I-BUF K-NREVERSE + ! ;                                                                                                                                                                       ( INDEX+  PRIMITIVES   P-NLEVEL@  ETC                         )                                                                 : P-NLEVEL@  ( n --- ) ( GETS LEVEL FROM BUF )                     I-BUF K-NLEVEL + @ ;                                         : P-NCOUNT@  ( n --- ) ( GETS COUNT FROM BUF )                     I-BUF K-NCOUNT + @ ;                                         : P-NSPACE@  ( n --- ) ( GETS SPACE FROM BUF )                     I-BUF K-NSPACE + @ ;                                         : P-NP0@     ( n --- ) ( GETS P0 FROM BUF )                        I-BUF K-NLEVEL + @ ;                                         : P-NFORWARD@  ( n --- ) ( GETS FORWARD FROM BUF )                 I-BUF K-NFORWARD + @ ;                                       : P-NREVERSE@  ( n --- ) ( GETS REVERSE FROM BUF )                 I-BUF K-NREVERSE + @ ;                                                                                                                                                                       ( INDEX+  PRIMITIVES    P-BUILDKEY P-?INDEX# P-?HIGHKEY P-?ROOT)                                                                : P-BUILDKEY  ( --- )  ( BUILD SEARCH KEY IN I-TEMPKEY )           I-SKEY @ I-TEMPKEY  OVER C@ 1+ CMOVE ( MOVE IN skey )           I-REC  @ I-TEMPKEY  DUP C@ 1+ + ! ;  ( SET rec# )                                                                            : P-?INDEX#  ( index# --- ec )  ( TEST FOR VALID INDEX# )          DUP K-INDEXES 1+ < SWAP 0> AND    ( 0 < index# <= K-INDEXES )     IF 0 ELSE E-INDEX# THEN ;       ( RETURN ERROR CODE )                                                                      : P-?HIGHKEY   ( key# --- tflag ) ( TESTS FOR KEY# PAST END )      P-NCOUNT@ - 0< ;                                                                                                             : P-?ROOT   ( --- tflag ) ( TESTS IF NODE IN BUFA IS ROOT )        P-A@ UDROP K-ROOT = ;                                                                                                        ( INDEX+  PRIMITIVES    P-HINIT    P-INITFCB                  )                                                                 : P-HINIT ( --- ) ( STORES HEADER INFO FROM BUFFA )                P-HEADER I-HEADER            ( SOURSE DESTINATION )             K-HDRLEN CMOVE ;             ( MOVE INFO )                                                                                   : P-INITFIB  ( fcb-addr index# --- ec )  ( INITIALIZE FIB )      ( 0 WARNING ! )              ( TURN OFF PC/FORTH ERROR MSG )      DUP P-?INDEX# 0=                                                IF K-FIBLEN * I-FIB +      ( NOW HAVE ADDR OF FIB + OFFSET )       SWAP OVER F-FCB + !     ( STORE FCB ADDR IN FCB )               K-ROOT OVER F-NODE + !  ( STORE FIRST NODE IN FCB )             0 SWAP F-KEY + ! 0      ( STORE FIRST KEY # IN FCB )         ELSE                                                               2DROP E-INDEX#          ( BAD INDEX# )                       THEN ;                                                       ( INDEX+  PRIMITIVES   P-INITROOT                             )                                                                 : P-INITROOT  ( index# --- ) ( INITIALIZE ROOT FOR NEW FILE )      K-ROOT P-A!                    ( SET BUFFER A AS NEW ROOT )     I-BUF K-1K ERASE               ( CLEAR ALL TO ZERO )            I-HEADER                       ( BASE ADDR OF HEADER IN MEM )   K-VERSION OVER H-VERSION + !   ( SET VERSION # )                K-ROOT    OVER H-FIRST   + !   ( SET FIRST PTR )                K-ROOT    OVER H-LAST    + !   ( SET LAST PTR )                 K-ROOT 1+ OVER H-NEXT    + !   ( SET NEXT NODE PTR )            K-ROOT    OVER H-EOF     + !   ( SET END OF FILE )              1         OVER H-LEVELS  + !   ( SET ONLY ONE LEVEL NOW )       P-HEADER K-HDRLEN CMOVE        ( MOVE HEADER INTO ROOT )        K-ROOTSIZE I-BUF K-NSPACE + !  ( SET FREE SPACE IN NODE )     ;                                ( REMAINING NODE VALUES=0 )                                                                   ( INDEX+  PRIMITIVES   P-BUFA?  P-BUFB?                       )                                                                 : P-BUFA?  ( index# node# --- tflag )                           ( TRUE IF BCB/A HOLDS MATHING INFORMATION )                        P-A@ D= ;                                                                                                                    : P-BUFB?  ( index# node# --- tflag )                           ( TRUE IF BCB/B HOLDS MATHING INFORMATION )                        P-B@ D= ;                                                                                                                    : P-HDRSET ( --- ) ( MOVE HEADER INTO ROOT NODE IN BUFFER A )      I-HEADER P-HEADER K-HDRLEN CMOVE ; ( DO THE MOVE )                                                                                                                                                                                                                                                                           ( INDEX+  BLANK SCREEN                                        )                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ( INDEX+  LOAD PRIMITIVE WORDS 2                              )                                                                 41 ILOAD   ( P-BUF? )                                           42 ILOAD   ( P-SCOMP )                                          43 ILOAD   ( P-KEYCOMP  P-INSLEN )                              44 ILOAD   ( P-LMOVEUP  P-IMOVEUP )                             45 ILOAD   ( P-MOVEUP  P-IKEYREC )                              46 ILOAD   ( P-SCAN )                                           47 ILOAD   ( P-ISCANDN )                                        48 ILOAD   ( P-ARRAY!  P-EC!  P-EC@ )                                                                                                                                                                                                                                                                                                                                                                                                                           ( INDEX+  PRIMITIVES   P-BUF?                                 )                                                                 : P-BUF?  ( index# node# --- buf-flag )                         ( TESTS IF EITHER BCB HOLDS MATCHING INFORMATION )              ( -1 = NOT FOUND  0 = FOUND IN BUFFER A  1 = FOUND IN BUFFER B )   2DUP P-BUFA?      ( IN BUFFER A ? )                             IF                                                               2DROP 0          ( SET FLAG )                                  ELSE                                                              P-BUFB?         ( IN BUFFER B ? )                               IF                                                                1             ( SET FLAG )                                    ELSE            ( NOT IN EITHER )                                 -1                                                            THEN                                                          THEN ;                                                       ( INDEX+  PRIMITIVES   P-SCOMP                                )                                                                 : P-SCOMP  ( skey-addr fkey-addr --- cflag ) ( string compare )     OVER C@ OVER C@ 2DUP - -ROT MIN  ( SA FA FL LN )                2SWAP ROT     ( =flag skey-addr fkey-addr len )                  1+ 1 0 -ROT ?DO          ( COMPARE STRING )                          DROP               ( DROP LAST COMPARISON FLAG )                OVER I + C@        ( FETCH SKEY CHAR )                          OVER I + C@        ( FETCH FKEY CHAR )                          -                  ( COMPARE CHARS )                            DUP IF LEAVE THEN  ( IF UNEQUAL, LEAVE )                    LOOP UDROP UDROP       ( = flag compflag )                    ?DUP IF UDROP THEN       ( IF NOT EQUAL, USE COMPFLAG )         P-CFLAG ;                ( SETS COMPARISON FLAG )                                                                                                                                           ( INDEX+  PRIMITIVES   P-KEYCOMP  P-INSLEN   ***!    01/09/84 ) : P-KEYCOMP   ( fkey-addr skey-addr --- cflag )                 ( FLAG = -1 IF KEY1<KEY2    0 IF KEY1=KEY2   1 IF KEY1>KEY2 )      OVER SWAP P-SCOMP  ( S-COMP ) ( COMPARE KEY VALUES )            ?DUP 0=                ( ARE KEYS =? )                            IF DUP C@            ( YES, GET KEY LENGTH )                       + 1+ @            ( NOW POINTING TO REC# OF KEY IN NODE)        I-REC @ - P-CFLAG ( COMPARE RECORD NUMBERS, RTN FLAG )       ELSE                 ( KEYS NOT EQUAL )                            UDROP             ( RETRIEVE ORIGINAL FLAG FROM P-SCOMP)     THEN ;                                                     : P-INSLEN  ( --- len ) ( GETS LEN OF KEY TO INSERT )              I-TEMPKEY C@ P-NLEVEL@                                          IF   5 9 VSEL +                ( ADD REC AND NODE IF INDEX )    ELSE 3 5 VSEL + THEN ;                 ( ELSE ONLY ADD REC )                                                                 ( INDEX+  PRIMITIVES   P-LMOVEUP  P-IMOVEUP          01/09/84 )                                                                 : P-LMOVEUP ( fkey-addr --- fkey-addr ) ( ADV KEY POS IN LEAF )    DUP C@     ( GET KEY LENGTH )                                   + 3 5 VSEL + ;           ( ADD LENGTH AND 2 BYTES FOR REC# )                                                                 : P-IMOVEUP ( fkey-addr --- fkey-addr ) ( ADV KEY POS IN INDEX )   DUP C@     ( GET KEY LENGTH )                                   + 5 9 VSEL + ;          ( ADD LENGTH, REC# AND NODE POINTER )                                                                                                                                                                                                                                                                                                                                                                                                                                                                ( INDEX+  PRIMITIVES   P-MOVEUP  P-IKEYREC           01/09/84 )                                                                 : P-MOVEUP    ( fkey-addr --- fkey-addr ) ( POINT TO NEXT KEY )    P-NLEVEL@          ( GET INDEX LEVEL )                            IF P-IMOVEUP     ( INDEX NODE SCAN )                            ELSE P-LMOVEUP   ( LEAF NODE SCAN )                             THEN ;                                                                                                                     : P-IKEYREC    ( fkey-addr --- fnode-addr ) ( PNT TO NODE PTR )     DUP C@     ( KEY LENGTH )                                      + 3 5 VSEL + ;        ( POINT TO ADDR OF DOWN NODE POINTER )                                                                                                                                                                                                                                                                                                                                 ( INDEX+  PRIMITIVES   P-SCAN                                 ) : P-SCAN ( nodeaddr --- fkeyaddr keycount ) ( NODE KEY SCAN )   ( KEY COUNT=0  IF NO KEYS IN NODE )                                DUP K-NBEGIN +               ( GET STARTING POSITION )          SWAP K-NCOUNT + @            ( GET KEY COUNT )                  DUP                          ( GO ON ONLY IF KEYS IN NODE )      IF 0 0 -ROT ?DO             ( COUNT IS LIMIT - STK = pos )           DROP DUP I-SKEY @                                               P-KEYCOMP              ( COMPARE SKEY TO KEY IN NODE )          -1 >                   ( NODE KEY => SKEY ? )                     IF I LEAVE           ( YES, STOP SCANNING )                     ELSE                                                               P-MOVEUP I 1+     ( ELSE ADVANCE POSITION )                  THEN                                                        LOOP 1+                                                      THEN ;                      ( PUT COUNT ON STACK, END )     ( INDEX+  PRIMITIVES   P-ISCANDN                     01/09/84 ) : P-ISCANDN ( nodeaddr --- nodeptr ) ( GETS PTR TO NEXT LEVEL )    DUP K-NP0    + @             ( GET P0 POINTER )                 SWAP DUP K-NBEGIN +          ( STARTING POSITION OF NODE )      SWAP K-NCOUNT + @ ?DUP       ( GET KEY COUNT )                    IF     ( P0 SA CNT )       ( ONLY SCAN IF NODE HAS KEYS )        0 ?DO                     ( KEY COUNT IS LIMIT )                   DUP I-SKEY @ P-KEYCOMP ( COMPARE KEY VALUES )                   -1 >                   ( NODE KEY => SKEY ? )                     IF LEAVE             ( YES, STOP SCANNING )                     ELSE                                                               P-IKEYREC DUP @   ( GET POINTER )                               UDROP3 SWAP       ( REPLACE OLD PTR WITH NEW )                  2 4 VSEL +                                                   THEN                                                       LOOP THEN DROP ;          ( DROP NODE POS OFF STACK )     ( INDEX+  PRIMITIVES   P-ARRAY!  P-EC!  P-EC@        01/09/84 )                                                                 : P-ARRAY!  ( --- ) ( STORES NODE# IN TREE SEARCH ARRAY )         P-A@ P-NLEVEL@                                                  2 4 VSEL *          ( index# node# levelsubscript )             I-STREE + ! DROP ;  ( STORE NODE# IN ARRAY, DROP INDEX# )                                                                     : P-EC! ( ec --- ) ( SAVE TEMP ERROE CODE )                         I-EC ! ;                                                                                                                    : P-EC@ ( --- ec ) ( RETURN TEMP ERROE CODE )                       I-EC @ ;                                                                                                                                                                                                                                                                                                                    ( INDEX+  BLANK SCREEN                                        )                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ( INDEX+  LOAD PRIMITIVE WORDS 3                              )                                                                 51 ILOAD   ( P-NEWNODE  P-NEWROOT )                             52 ILOAD   ( P-INSERT )                                         53 ILOAD   ( P-FINDSPLIT  P-CLRB )                              54 ILOAD   ( P-BUILDA )                                         55 ILOAD   ( P-BUILDB )                                         56 ILOAD   ( P-DELETE )                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ( INDEX+  PRIMITIVES   P-NEWNODE  P-NEWROOT    ****!          )                                                                 : P-NEWNODE   ( --- node# ) ( GETS NEXT NODE#, REVISES HDR )       I-HEADER H-NEXT + DUP @     ( STK= ADR NODE# )                  DUP 1+ ROT ! ;              ( SET NEW NEXT NODE IN HEADER )                                                                  : P-NEWROOT  ( --- ) ( CREATE NEW ROOT NODE DURING SPLIT )         K-NBEGIN I-BUF + K-NODESIZE ERASE  ( CLEAR ENTIRE NODE )        I-ANODE @ P-NP0!                   ( SET P0 PTR )               P-NLEVEL@ 1+ P-NLEVEL!             ( SET LEVEL )                K-ROOTSIZE P-NSPACE! ( L! )            ( SET FREE SPACE )       0 P-NCOUNT!                        ( SET KEY COUNT )            0 P-NFORWARD!                      ( SET NO FWD PTR)            0 P-NREVERSE!                      ( SET NO REV PTR)            P-HDRSET P-A@ DROP K-ROOT P-A! ;   ( SET HEADER INTO BUFFER )                                                                ( INDEX+  PRIMITIVES   P-INSERT                               )                                                                 : P-INSERT    ( fkeyaddr --- )  ( INSERTS TEMPKEY AT FKEYADDR )    P-INSLEN OVER    ( SAVE FKEYADDR AND KEYLEN FOR LATER )         I-BUF K-1K +     ( GET END OF NODE )                            P-?ROOT IF       ( ROOT NODE ? )                                   K-HDRLEN -    ( SUBSTRACT HEADER LENGTH )                    THEN                                                            P-NSPACE@ -      ( POINTS TO END OF NODE DATA )                 OVER -           ( NUMBER OF BYTES TO MOVE )                    OVER 3 PICK      ( GET LEN OF KEY TO INSERT )                   +                ( ADD TO BEG ADDR TO GET DESTINATION ADDR )    SWAP -CMOVE      ( MOVE NODE TO RIGHT ) ( STK=FKEYADDR LEN )    I-TEMPKEY -ROT   ( STK=FROM TO LEN )                            CMOVE ;                                                                                                                      ( INDEX+  PRIMITIVES   P-FINDSPLIT  P-CLRB                    ) : P-FINDSPLIT ( --- b-addr acnt endb-addr) ( FINDS SPLIT POS)      1 I-NOSPLIT !              ( STARTING< NO SPLIT YET )           I-BUF K-NBEGIN +           ( GET STARTING ADDR )                P-NCOUNT@ 0 ?DO            ( STK = ADDR /or/ ADDR ACNT ADDR )      DUP K-SPLIT > I-NOSPLIT @ AND  ( SPLIT < ADDR ? )               IF I  OVER 0 I-NOSPLIT !  ( SET KEY NUMBER, FOUND SPLIT )       ELSE I-NOSPLIT @                                                     IF DUP I-HIGHKEY ! THEN ( STORE HIGH KEY ADDR )                 P-MOVEUP           ( MOVE TO NEXT KEY )                    THEN                    ( LOOP UNTIL PAST SPLIT LIMIT )      LOOP P-MOVEUP ;            ( STK = ADDR ACNT ADDR )                                                                          : P-CLRB  ( --- ) ( CLEARS BUFFER B )                              I-BUF K-1K + K-1K ERASE       ( CLEAR BUFFER )                  -1 -1 P-B! ;                  ( CLEAR CBC/B )                ( INDEX+  PRIMITIVES   P-BUILDA       ****!                   ) : P-BUILDA   ( --- bcnt ) ( BUILD NODE A AND MOVES NODE B )        P-FINDSPLIT                             ( GET SPLIT INFO )      I-HIGHKEY @ I-TEMPKEY OVER C@ 5 9 VSEL + CMOVE ( -> TEMPKEY)    I-TEMPKEY DUP C@ 3 5 VSEL + + @ I-TEMPP0 ! ( SV P0 NODE B )     2 PICK - 2 PICK                  ( B-ADDR ACNT B-LEN B-ADDR )   I-BUF K-1K + K-NBEGIN + ROT -CMOVE   ( MOVE B INFO TO BUF B )   SWAP I-BUF K-1K + OVER -      ( CALC FREE SPACE IN NODE A )     DUP P-NSPACE! ERASE           ( SET FREE SPACE AND ERASE )      P-NCOUNT@ OVER -              ( CALC BCNT )                     SWAP P-NCOUNT!                ( STORE ACNT )                    P-NFORWARD@ I-TEMPFWD !       ( SAVE FWD FOR NODE B )           P-NEWNODE DUP P-NFORWARD!    ( STORE FORWARD PTR )              DUP I-TEMPKEY DUP C@ 3 5 VSEL + + !  ( SET PTR TO NODE B )      P-A@ DROP SWAP P-B! ;         ( SET BCB/B )                                                                                  ( INDEX+  PRIMITIVES   P-BUILDB                               ) : P-BUILDB  ( bcnt --- ) ( BUILDS NODE B IN BUFA )                 P-A@ UDROP       ( GET NODE# OF A FOR REV )                     P-NLEVEL@        ( GET LEVEL ) ( STK=BCNT NODE# LEVEL )         P-B>A P-CLRB     ( MOVE TO A, CLEAR BUFB )                      P-NLEVEL!        ( SET LEVEL )                                  DUP I-ANODE !    ( SAVE PTR TO NODE A FOR POSSIBLE NEWROOT )    P-NREVERSE!      ( SET REVERSE PTR TO POINT TO NODEA )          I-TEMPFWD @ P-NFORWARD!   ( SET FORWARD PTR )                   P-NLEVEL@ IF I-TEMPP0 @   ( IF NOT LEAF, GET P0 PTR )                     ELSE 0 THEN  P-NP0!  ( SET P0 PTR )                   DUP P-NCOUNT!             ( SET KEY COUNT )                     I-BUF K-NBEGIN + SWAP     ( CALC BEGINNING NODE ADDR )          0 ?DO P-MOVEUP LOOP       ( FIND END OF KEYS )                  I-BUF K-1K + OVER -  DUP  ( CALC SPACE LEFT )                   P-NSPACE! ERASE ;         ( SET SPACE AND CLEAR REMAINDER )  ( INDEX+  PRIMITIVES   P-DELETE         ****!                 )                                                                 : P-DELETE ( fkey-addr --- ) ( REMOVE KEY FROM NODE IN BUF A )      DUP P-MOVEUP OVER -           ( CALC LENGTH OF DEL KEY )        P-NSPACE@ + P-NSPACE!         ( INCREASE AVALIABLE SPACE )      I-BUF K-NBEGIN +              ( BEGINNING OF KEYS )             P-NCOUNT@ 0 ?DO P-MOVEUP LOOP  ( ADDR OF PAST END KEY )         OVER P-MOVEUP SWAP OVER -     ( FA NA NLEN )                    ROT SWAP CMOVE                ( REMOVE THE KEY )                P-NCOUNT@ 1- DUP P-NCOUNT!    ( DECREASE KEY COUNT )            I-BUF K-NBEGIN + SWAP         ( NBEGIN COUNT )                  ?DUP                          ( IF HAVE ANY KEYS )                IF 0 ?DO P-MOVEUP LOOP THEN  ( MOVE PAST NEW END ADDR )       I-BUF K-1K + OVER - ERASE ;   ( CLEAR TO END OF BUFFER )                                                                                                                                    ( INDEX+  BLANK SCREEN                                        )                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ( INDEX+  BLANK SCREEN                                        )                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ( INDEX+  BLANK SCREEN                                        )                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ( INDEX+  LOAD INTERMEDIATE WORDS 1                           )                                                                 61 ILOAD   ( I-READ )                                           62 ILOAD   ( I-WRITE )                                          63 ILOAD   ( I-ROOTREAD I-ENDWRITE )                            64 ILOAD   ( I-TREESEARCH )                                     65 ILOAD   ( I-NEXT )                                           66 ILOAD   ( I-LOC  I-FIND )                                    67 ILOAD   ( I-BUILDA )                                         68 ILOAD   ( I-BUILDB )                                         69 ILOAD   ( I-READUP )                                                                                                                                                                                                                                                                                                                                                                         ( INDEX+  INTERMEDIATE WORDS   I-READ                         )                                                                 : I-READ  ( node# --- ec ) ( READ INDEX NODE )                     I-IND @ OVER P-BUF?  ( CHECK TO SEE IF IN BUFFER )              DUP -1 = 0=  IF      ( IF FOUND IN BUFFER )                       IF P-B>A THEN      ( IF ITS IN BUFFER B, MOVE TO BUFFER A )     DROP 0             ( NO ERRORS )                              ELSE  DROP           ( NOT IN BUFFERS, MUST READ )                I-IND @ SWAP 2DUP  ( PRIMITIVE NODE READ )                      P-READ ?DUP                                                     IF 2 UDROPS        ( RETURN ERROR )                             ELSE 2DUP P-A!     ( SET BCB FOR BUFFER A )                        UDROP K-ROOT =  ( IF ITS A ROOT NODE )                          IF P-A>B THEN   ( SAVE ROOT IN BUFFER B )                    0 THEN                                                        THEN ;                                                       ( INDEX+  INTERMEDIATE WORDS   I-WRITE                        )                                                                 : I-WRITE   ( buf-flag  --- ec ) ( WRITE CONTENTS OF BUFFER )      K-BUFB =                   ( IN BUFFER B ? )                     IF                                                                   P-B@ I-BUF K-1K +    ( YES, GET BUFB INFO )                ELSE                                                                 P-A@ I-BUF           ( NO, GET BUFA INFO  )                THEN                                                           P-WRITE ;                  ( WRITE NODE )                                                                                                                                                                                                                                                                                                                                                                                                                    ( INDEX+  INTERMEDIATE WORDS   I-ROOTREAD  I-ENDWRITE         )                                                                 : I-ROOTREAD ( --- ) ( READ THE ROOT NODE INTO BUFFER A )           K-ROOT I-READ P-EC! ;                                                                                                       : I-ENDWRITE ( --- ec ) ( WRITES LAST NODE IN INSERT, UPDT HDR )   K-BUFA I-WRITE ?DUP 0=  ( WRITE NODE )                           IF P-NLEVEL@           ( IF NO WRITE ERROR, TEST FOR SPLIT )     IF I-ROOTREAD P-EC@ ?DUP 0= ( GET NODE B#, THEN READ ROOT )      IF P-HDRSET K-BUFA I-WRITE P-CLRB ( UPDATE HDR IN ROOT )        THEN                                                           ELSE 0                ( ELSE NO SPLIT, ZERO ERROR CODE )        THEN                                                           THEN ;                                                                                                                                                                                      ( INDEX+  INTERMEDIATE WORDS   I-TREESEARCH                   )                                                                 : I-TREESEARCH ( --- fkey-addr keycount ec ) ( SEARCHES TREE )     I-ROOTREAD P-HINIT P-ARRAY!   ( READ ROOT NODE FIRST )            BEGIN                       ( LOOP LOOKING DOWN TREE )           P-NLEVEL@ 0> P-EC@ 0= AND  ( LOOP UNTIL LEAF, OR ERROR )       WHILE                       ( UNTIL AT LEAF LEVEL )                   I-BUF P-ISCANDN       ( LOOK FOR LOWER LEVEL NODE )             I-READ P-EC!          ( READ NEXT LOWER NODE )                  P-ARRAY!              ( SAVE SEARCH PATH )                REPEAT                                                        P-EC@ ?DUP                                                        IF 0 0 ROT                  ( DISK READ ERROR )                 ELSE I-BUF P-SCAN 0 THEN ;  ( FOUND LEAF KEY POINTER )                                                                                                                                     ( INDEX+  INTERMEDIATE WORDS   I-NEXT                         ) : I-NEXT  ( --- fkey-addr ec ) ( LOCATE THE NEXT KEY IN ORDER )     0 P-EC!                               ( CLEAR ERROR CODE )      BEGIN                                                             P-CFIB DUP F-NODE + @ I-READ P-EC!  ( READ NODE FOR NEXT )      F-KEY + 1 OVER +! @                 ( INC NEXT KEY # )          P-NFORWARD@ 0>                      ( TEST HAVE FWD NODE )        IF P-NCOUNT@ > P-EC@ 0= AND   ( WHILE PAST END OF NODE )        ELSE DROP 0 THEN              ( ELSE NO FORWARD NODE )     WHILE P-CFIB P-NFORWARD@ OVER F-NODE + ! ( SET NEW NEXT NODE)         F-KEY + 0 SWAP !                   ( ZERO KEY # )         REPEAT                                                          P-CFIB F-KEY + @ DUP P-NCOUNT@ > 0= P-EC@ 0= AND                  IF I-BUF K-NBEGIN + SWAP 1 2DUP =       ( TEST HAVE KEY )          IF 2DROP ELSE DO P-MOVEUP LOOP THEN  ( YES, POS TO KEY )     ELSE 1- P-CFIB F-KEY + ! 0 THEN P-EC@ ; ( ELSE NO KEY )    ( INDEX+  INTERMEDIATE WORDS   I-LOC  I-FIND                  ) : I-NEXTSET ( keycount --- ) ( SET LOC FOR NEXT )                   P-A@ SWAP K-FIBLEN * I-FIB +      ( CALC FIB ADDR )             SWAP OVER F-NODE + ! F-KEY + ! ;  ( SET NODE# AND KEY# )    : I-LOC  ( --- fkey-addr ec ) ( FIND KEY FOR ADD, DELETE )          I-TREESEARCH ?DUP         ( SEARCH THE KEY FOR LOCATION )        IF UDROP                 ( ERROR )                              ELSE I-NEXTSET 0 THEN ;  ( SAVE LOCATION FOR NEXT )        : I-FIND ( --- fkey-addr ec )  ( FIND KEY FOR B-FIND )              I-TREESEARCH ?DUP           ( SEARCH TREE FOR KEY LOCATION )      IF UDROP                  ( ERROR SEARCHING )                   ELSE DUP I-NEXTSET        ( SET LOC FOR NEXT )                       P-NCOUNT@ SWAP - 0<  ( TEST IF PAST END OF KEYS )               IF DROP I-NEXT       ( YES, GET NEXT KEY )                      ELSE 0 THEN          ( ELSE ALREADY HAVE KEY )             THEN ;                                                    ( INDEX+  INTERMEDIATE WORDS   I-BUILDA                       )                                                                 : I-BUILDA  ( --- bcnt ) ( BUILDS NODEA, MOVES B, WRITES A )       P-EC@                                                           IF 0 P-CLRB P-B>A                 ( ERROR, RTN DMY, CLR BUFS)   ELSE P-?ROOT                      ( NO ERROR, CONTINUE )          IF P-NEWNODE                    ( IF NODE IN A IS ROOT )         P-A@ DROP SWAP P-NLEVEL@ 0=    ( NODE A GETS NEW NODE# )          IF DUP I-HEADER H-FIRST + ! ( UPDATE HEADER)                    THEN                                                          P-A!                           ( UPDATE BCB/A )                THEN                                                           P-BUILDA                         ( BUILD A, MOVE B )            K-BUFA I-WRITE P-EC!             ( WRITE NODE A )              THEN ;                                                                                                                       ( INDEX+  INTERMEDIATE WORDS   I-BUILDB                       )                                                                 : I-BUILDB  ( --- bcnt ) ( BUILDS NODE B, WRITES NODE B )          P-EC@                                                             IF DROP                 ( CONTINUE, ONLY IF NO ERROR )          ELSE  P-BUILDB          ( MOVE B TO BUFA AND BUILD NODE B )           K-BUFA I-WRITE P-EC!    ( ERITE NODE B )                        P-NLEVEL@ 0=                                                    P-NFORWARD@ 0= AND      ( IF LAST LEAF )                         IF P-A@ UDROP          ( GET PTR TO NODE B - LAST )                I-HEADER H-LAST + ! ( UPDATE LAST PTR IN HEADER )            THEN                                                     THEN ;                                                                                                                                                                                                                                                     ( INDEX+  INTERMEDIATE WORDS   I-READUP                       )                                                                 : I-READUP ( --- )  ( READ UPPER NODE IN TREE PATH )               P-EC@ 0=         ( DO ONLY IF NO ERROR FROM PREV ROUTINE )       IF P-NLEVEL@ 1+               ( GET NEXT LEVEL )                 DUP I-HEADER H-LEVELS + @ =  ( GET NUMBER OF LEVELS )            IF 1+ I-HEADER H-LEVELS + ! ( IF ROOT SPLIT, INCR LEVELS )       P-NEWROOT                  ( INIT ROOT )                       ELSE                                                             2 4 VSEL * I-STREE + @     ( GET NODE NUMBER OF ABOVE )         I-READ                     ( READ UP )                          P-EC! P-CLRB               ( CLEAR BUFFER B )                  THEN                                                         THEN ;                                                                                                                                                                                       ( INDEX+  LOAD INTERMEDIATE WORDS 2                           )                                                                 71 ILOAD   ( I-UPDATEC )                                        72 ILOAD   ( I-EXTEND )                                         73 ILOAD   ( I-INSERT )                                         74 ILOAD   ( I-NF  I-REC# )                                     75 ILOAD   ( I-RET I-FRET )                                     76 ILOAD   ( I-PREV )                                           77 ILOAD   ( I-FIRST )                                          78 ILOAD   ( I-LAST )                                           79 ILOAD   ( I-DELETE )                                                                                                                                                                                                                                                                                                                                                                         ( INDEX+  INTERMEDIATE WORDS   I-UPDATEC                      )                                                                 : I-UPDATEC  ( --- ) ( UPDATE REVERSE POINTER IN NODE C )         P-EC@ 0=                                                          IF P-NLEVEL@ 0= P-NFORWARD@ 0>                                    AND                  ( IF LEAF NODE AND HAVE FORWARD PTR)       IF P-A@ UDROP                 ( GET NODE B PTR )                   P-NFORWARD@ I-READ ?DUP    ( READ NODE C )                       IF   UDROP                ( ERROR READING NODE C )              ELSE                                                                 P-NREVERSE!        ( SET NEW REV PTR TO NODE B)                 K-BUFA I-WRITE P-EC! ( RE-WRITE NODE C )                   THEN                                                        THEN                                                          THEN ;                                                                                                                      ( INDEX+  INTERMEDIATE WORDS   I-EXTEND                       ) : I-EXTEND  ( --- ec ) ( EXTEND FILE BEFORE INSERT IF NEEDED )     K-ROOT I-READ P-HINIT        ( READ HEADER INTO MEM )             BEGIN  ( STK=EC )          ( START WITH DUMMY ERROR CODE )       I-HEADER H-EOF OVER + @                                               H-NEXT 2 PICK + @ - ( EOF-NEXT )                                H-LEVELS  ROT + @ - ( ADJUST FOR POSSIBLE SPLITS )              0< OVER 0= AND ( EXTEND IF NEED MORE NODES, NO EC )      WHILE DROP I-HEADER H-EOF + 1 OVER +! @ ( NEW EOF )              P-A@ DROP SWAP P-A!               ( SET NEW EOF IN BUF A )      K-BUFA I-WRITE ?DUP 0=            ( WRITE BUF A )                IF I-ROOTREAD P-EC@ ?DUP 0=      ( READ ROOT FOR UPDATE )         IF P-HDRSET                    ( SET HEADER VALUES )               K-BUFA I-WRITE P-CLRB THEN  ( REWRITE HEADER )             THEN                                                          REPEAT ;                                                   ( INDEX+  INTERMEDIATE WORDS   I-INSERT                       ) : I-INSERT   ( fkey-addr --- ec ) ( INSERT KEY INTO NODE )         0 P-EC!                                ( CLEAR ERRORS )         BEGIN P-EC@ IF 0 ELSE            ( IF ERRORS, SKIP )               P-INSERT P-NCOUNT@ 1+ P-NCOUNT!  ( INCREMENTS KEY COUNT )       P-NSPACE@ P-INSLEN - DUP P-NSPACE! ( UPDATE SPACE )             0< P-EC@ 0= AND THEN          ( WHILE NO ERROR AND SPLIT )   WHILE              ( STK = NULL )                                   I-EXERR @ P-EC! ( INDICATE POSSIBLE EXTEND ERRORS )             I-BUILDA        ( BUILD AND WRITE NODE A ) ( STK=BCNT )         I-BUILDB        ( BUILD AND WRITE NODE B )                      I-UPDATEC       ( UPDATE REVERSE POINTER OF NODE C )            I-READUP        ( READ NODE ABOVE IN SEARCH PATH )              P-EC@ 0= IF I-BUF P-SCAN DROP THEN   ( SCAN IF NO ERRORS)   REPEAT                                                          P-EC@ ?DUP 0= IF I-ENDWRITE THEN ; ( FINAL WRITES )          ( INDEX+  INTERMEDIATE WORDS   I-NF    I-REC#                 )                                                                 : I-NF  ( fkey-addr ec --- fkey-addr rec3 cc ec ) ( NOT FOUND )    0 -1 ROT ;                                                                                                                   : I-REC# ( fkey-addr --- rec# ) ( RETURN FOUND KEY RECORD # )      COUNT + @ ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ( INDEX+  INTERMEDIATE WORDS   I-RET   I-FRET                 ) : I-RET  ( fkey-addr ec --- fkey-addr rec# cc ec )                       ( SET RETURN VALUES FOR ALL FIND OPERATIONS )            ?DUP IF I-NF                        ( NOT FOUND )                    ELSE DUP 0= P-NCOUNT@ 0= OR    ( NOT FOUND NOTHING )               IF 0 I-NF                   ( NOT FOUND ERROR )                 ELSE DUP I-REC#        ( RETURN REC# )                               I-SKEY @ 0=       ( TEST NOT B-FIND OR B-DELETE )             IF 0 0              ( RETURN FOUND REC# )                       ELSE OVER I-SKEY @  ( GET SKEY-ADDR )                                P-KEYCOMP 0    ( SET CC, EC )                        THEN THEN THEN ;                                         : I-FRET  ( fkey-addr ec --- fkey-addr rec# cc ec )                       ( SET RETURN VALUES FOR B-FIND )                         DUP 0= IF OVER I-REC# I-REC ! THEN ( SET REC# TO FOUND )        I-RET  ;                           ( THEN SET RETURN )       ( INDEX+  INTERMEDIATE WORDS   I-PREV                         ) : I-PREV  ( --- fkey-addr ec ) ( LOCATE THE PREV KEY IN ORDER )     0 P-EC! BEGIN P-EC@ IF 0 ELSE    ( CLEAR ERROR CODE, & TEST)      P-CFIB DUP F-NODE + @ I-READ P-EC!  ( READ NODE FOR NEXT )      F-KEY + -1 OVER +! @                ( INC NEXT KEY # )          P-NREVERSE@ 0>                      ( TEST HAVE FWD NODE )        IF 1 < P-EC@ 0= AND   ( WHILE BEFORE BEGINNING OF NODE )        ELSE 1 <              ( IF BEF BEG AND NO REVERSE )               IF 0 P-CFIB F-KEY + ! THEN 0 THEN THEN  ( SET TO 0)      WHILE P-CFIB P-NREVERSE@ OVER F-NODE + ! ( SET NEW NEXT NODE)         P-NREVERSE@ I-READ P-EC!           ( READ REVERSE NODE)         F-KEY + P-NCOUNT@ 1+ SWAP ! REPEAT ( SET PAST END )       P-CFIB F-KEY + @ DUP 0> P-EC@ 0= AND     ( IF FOUND KEY )         IF I-BUF K-NBEGIN + SWAP 1 2DUP =      ( TEST HAVE 1ST KEY)        IF 2DROP ELSE DO P-MOVEUP LOOP THEN ( POSITION TO KEY )      ELSE DROP 0 P-CFIB F-KEY + ! 0 THEN P-EC@ ;                ( INDEX+  INTERMEDIATE WORDS   I-FIRST  I-FL                  )                                                                 : I-FL    ( --- hdr-addr ec ) ( SET UP FOR FIRST/LAST KEY READ )    K-ROOT I-READ ?DUP               ( READ IN ROOT )                IF 0 SWAP                       ( ERROR IN READ )               ELSE P-HINIT P-HEADER 0 THEN ;  ( INIT HEADER IN MEMORY )                                                                  : I-FIRST ( --- ec ) ( SET NEXT PTR BEFORE FIRST KEY )              I-FL ?DUP                                                        IF UDROP                                                        ELSE P-CFIB SWAP H-FIRST + @    ( GET FIRST NODE # )                 OVER F-NODE + !            ( SET NODE# )                        0 SWAP F-KEY + ! 0         ( SET KEY # TO ZERO )           THEN ;                                                                                                                                                                                     ( INDEX+  INTERMEDIATE WORDS   I-LAST                         )                                                                 : I-LAST ( --- ec ) ( SET NEXT/PREV PTRS FOR READ LAST )            I-FL ?DUP              ( SET UP HEADER )                         IF UDROP              ( ERROR )                                 ELSE H-LAST + @       ( GET HEADER LAST NODE PTR )                   I-READ ?DUP 0=   ( READ IN LAST NODE )                      IF P-CFIB P-A@ UDROP ( CFIB NODE# )                                OVER F-NODE + !   ( SET LAST NODE )                             P-NCOUNT@ 1+      ( PNT PAST LAST KEY )                         SWAP F-KEY + !    ( SET KEY # FOR PREV )                        0                 ( NO ERRORS )                              THEN                                                           THEN ;                                                                                                                                                                                     ( INDEX+  INTERMEDIATE WORDS   I-DELETE                       )                                                                 : I-DELETE ( fkey-addr --- ec ) ( DELETE KEY ENTRY FROM NODE )      P-DELETE                     ( REMOVE KEY FROM NODE )           P-CFIB F-KEY + -1 SWAP +!    ( DECR NEXT KEY PTR )              I-HEADER H-LEVELS + @        ( GET NUMBER OF INDEX LEVELS )     1 = IF P-HDRSET THEN         ( IF 1, RESTORE HEADER INFO )      K-BUFA I-WRITE ;             ( REWRITE TO DISK )                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ( INDEX+  LOAD HIGH LEVEL WORDS                               )                                                                 81 ILOAD   ( B-ADD )                                            82 ILOAD   ( B-DELETE )                                         83 ILOAD   ( B-FIND )                                           84 ILOAD   ( B-NEXT )                                           85 ILOAD   ( B-PREV )                                           86 ILOAD   ( B-FIRST )                                          87 ILOAD   ( B-LAST )                                           88 ILOAD   ( B-INIT )                                           89 ILOAD   ( B-CREATE )                                                                                                                                                                                                                                                                                                                                                                         ( INDEX+  HIGH LEVEL     B-ADD                                )                                                                 : B-ADD ( skey-addr rec# index# --- ec ) ( add key to index )      DUP P-?INDEX#  ?DUP              ( TEST INDEX # )                IF 3 UDROPS                     ( ERROR INDEX# )                ELSE P-3PARM!                   ( SAVE PARAMETERS ON STACK )         I-EXTEND I-EXERR !        ( ATTEMPT TO EXTEND FILE )            I-LOC ?DUP                 ( FIND LOC FOR KEY INSERT )            IF UDROP                 ( ERROR FINDING INSERT LOC )           ELSE P-BUILDKEY          ( BUILD KEY IN TEMPKEY BUF )                I-INSERT            ( INSERT THE KEY )                     THEN                                                     THEN ;                                                                                                                                                                                                                                                      ( INDEX+  HIGH LEVEL     B-DELETE                             )                                                                 : B-DELETE  ( skey-addr rec# index# --- cc ec )                     P-3PARM!                    ( SAVE THE PARAMETTERS )            I-LOC                       ( FIND KEY TO DELETE )              I-RET  2DUP OR              ( TEST FOUND KEY )                     IF UDROP3 UDROP3         ( ERROR, DROP fkey-addr, rec# )        ELSE 3 DROPS             ( OK, DROP rec#, cc, ec )                   I-DELETE            ( REMOVE KEY FROM NODE )                    0 SWAP              ( RETURN cc=0, ec )                    THEN ;                                                                                                                                                                                                                                                                                                                                                                                   ( INDEX+  HIGH LEVEL     B-FIND                               )                                                                 : B-FIND  ( skey-addr index# --- fkey-addr rec# cc ec )                   ( FIND THE SEARCH KEY IN THE INDEX )                     DUP P-?INDEX# ?DUP 0=                   ( TEST GOOD INDEX# )     IF P-2PARM!                            ( SAVE PARMS )              I-FIND                              ( DO SEARCH )               I-FRET                              ( SAVE RETURN CODES )    ELSE                                                               UDROP 0 SWAP I-NF                   ( BAD INDEX )            THEN ;                                                                                                                                                                                                                                                                                                                                                                                      ( INDEX+  HIGH LEVEL     B-NEXT                               )                                                                 : B-NEXT  ( index# --- fkey-addr rec# cc ec ) ( find next key )    DUP P-?INDEX# ?DUP 0=              ( TEST GOOD INDEX# )          IF P-1PARM!                       ( SAVE PARAMETERS )              I-NEXT                         ( FIND NEXT KEY )                I-FRET                         ( SAVE RETURN VALUES)         ELSE UDROP 0 SWAP I-NF            ( NOT FOUND, BAD INSEX )      THEN ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ( INDEX+  HIGH LEVEL     B-PREV                      04/09/88 )                                                                 : B-PREV  ( index# --- fkey-addr rec# cc ec ) ( find next key )    DUP P-?INDEX# ?DUP                 ( TEST INDEX# )               IF UDROP 0 SWAP I-NF              ( BAD INDEX )                 ELSE P-1PARM!                     ( SAVE PARAMETERS )              I-PREV                         ( FIND PREVIOUS KEY )            I-FRET                         ( SAVE RETURN VALUES )        THEN ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ( INDEX+  HIGH LEVEL     B-FIRST                              )                                                                 : B-FIRST  ( index# --- fkey-addr rec# cc ec ) ( first key )       DUP P-?INDEX# ?DUP                                               IF UDROP 0 SWAP I-NF        ( ERROR WITH INDEX# )               ELSE P-1PARM!               ( SAVE PARAMETER )                       I-FIRST ?DUP           ( LOCATE FIRST KEY )                       IF 0 SWAP I-NF       ( ERROR IN SETTING FIRST )                 ELSE I-NEXT          ( GET NEXT KEY - I.E. FIRST )                   I-RET           ( SAVE RETURN VALUES )                     THEN                                                     THEN ;                                                                                                                                                                                                                                                                                                                      ( INDEX+  HIGH LEVEL     B-LAST                               )                                                                 : B-LAST   ( index# --- fkey-addr rec# cc ec ) ( last key )        DUP P-?INDEX# ?DUP                                               IF UDROP 0 SWAP I-NF        ( BAD INDEX# )                      ELSE P-1PARM!                     ( SAVE PARAMETER )                 I-LAST ?DUP                  ( LOCATE LAST KEY )                  IF UDROP 0 SWAP I-NF       ( ERROR SETING LAST KEY )            ELSE I-PREV          ( DO PREV TO GET KEY )                          I-RET           ( SET UP RETURN PARMS )                    THEN                                                     THEN ;                                                                                                                                                                                                                                                                                                                      ( INDEX+  HIGH LEVEL     B-INIT                      02/13/91 )                                                                 : B-INITS ( fcb-addr index# --- ec |initialize index# for use)     DUP P-?INDEX# ?DUP           ( TEST INDEX# )                     IF 2 UDROPS                 ( BAD# )                            ELSE DUP P-1PARM!           ( SAVE INDEX# )                          P-CLRB P-B>A           ( CLEAR BUFFER B AND BUFFER A )          P-INITFIB  ?DUP    0=  ( INITIALIZE FIB FOR index# )         IF I-FIRST                ( SET NEXT KEY TO ZERO )              THEN                                                          THEN ;                                                                                                                                                                                                                                                                                                                                                                                      ( INDEX+  HIGH LEVEL     B-CREATE                    02/13/91 )                                                                 : B-CREATE ( fcb-addr index# --- ec ) ( create new index file )     2DUP P-INITFIB  ?DUP        ( SET UP FIB FOR index# )             IF UDROP UDROP            ( ERROR - DROP UNUSED PARMS )       ELSE UDROP DUP P-1PARM!     ( SAVE INDEX# FOR SET FIRST KEY)         P-CLRB                 ( CLEAR OUT BUFFER B )                   P-INITROOT             ( INITIALIZE NEW ROOT IN BUFA )          K-BUFA I-WRITE ?DUP 0=   ( WRITE OF NEW HEADER/ROOT )        IF I-EXTEND  ?DUP 0=        ( EXTEND FILE FOR LATER AIDS)         IF I-FIRST                ( SET NEXT KEY PTR TO FIRST )         THEN                                                          THEN                                                          THEN ;                                                                                                                                                                                      (                                                    02/13/91 ) ;S                                                                                                                                                                                                                                                              n faili korraga ees:                                            teen massiivi P[0..n-1]; P[i] = IX-PARM.i                       for i:= 0 step 1 until n-1 do                                    begin 0 IX-PARM ! B-INIT IX-PARM @ I 4 * P + ! end;            kasutades: P[i] @ IX-PARM ! b-tegevus                                                                                                                                                                                                                                                                                                                                                                                                                           